## 0. 배경
### 0.1 Race Condition (경쟁 상태)
- 여러 개의 프로세스가 병행하여 공유 자원을 읽고 쓸때 발생하는 상황
- 공유 자원 접근 순서에 따라 실행 결과가 매번 달라지는 문제! - <span style="color:orange">non-deterministic</span>
- <span style="color:BLUE">동기화 매커니즘(Synchronization)</span>이 필요한 이유

### 0.2 Critical Section (임계 구역)
- 둘 이상의 프로세스/스레드가 동시에 실행될 경우 생길 수 있는 경쟁 조건(race condition)을 발생시킬 수 있는 코드 영역.

- **임계 구역 해결 조건**
  - **Mutual Exclusion (상호 배제)**
이미 한 프로세스가 임계 구역에서 실행 중 이라면, 다른 프로세스는 접근할 수 없다.

  - **Progress (진행)**
임계 구역에 프로세스가 없을 때, 임계 구역에 접근하고자 하는 프로세스가 있다면 진입할 수 있어야 한다. 
  - **Bounded Waiting (한정 대기)**
프로세스가 Critical Section에 진입하기 위해 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 Critical Section에 들어가는 횟수에 제한이 있어야 한다. 무한 대기 X

---
## 1. 동기화 메커니즘 (Synchronization Mechanism)
### 1.1 동기화
- 프로세스/스레드가 공유 자원에 동시에 접근하지 못하도록 접근 순서를 제어하는 방법.
-> 여러 프로세스/스레드를 동시에 실행해도, 공유 자원의 일관성을 유지하는 것.
- 스핀락, 뮤텍스, 세마포어 등이 있다.

### 1.2 Lock
- 락/잠금
- 공유 자원을 특정 프로세스/스레드가 사용하고 있을 때, 다른 프로세스/스레드는 해당 공유 자원에 접근할 수 없도록 제한하는 것
**ex)** 스레드 A가 접근하면 공유 자원에 lock을 걸어(=acquire) 다른 스레드가 접근하지 못하게 함. 스레드 A의 작업이 종료되면 락을 풀고 (=release =unlock) 대기(wait) 중이던 스레드가 작업을 수행하게 됨.
```c
while (true) {
	acquire(); //acquire lock

    /* critical section */
    
    release(); //release lock
    
    /* remainder section */
}
```
 

이렇게 스레드를 순차적으로 실행하게 만들면 공유 자원의 동기화를 구현할 수 있다. 

### 1.2 Spin Lock
- 스레드가 락을 얻을 때까지 무한 루프를 돌며 확인하는 메커니즘
- 대기 중인 스레드가 공유 자원의 상태를 무한 루프를 돌며 확인하는 방식
- busy waiting -> CPU 낭비
컨텍스트 스위칭 시간이 더짧을때, 멀티코어 상태일때 사용
### 1.3 Mutex(MUTual EXclusion)
- Critical Section Problem을 해결하기 위한 가장 간단한 소프트웨어 Tool
- Mutual Exclusion을 따르기 때문에 lock이 하나만 존재한다.
- 공유 자원이 하나일 때 사용하는 동기화 방법.
- lock을 걸고(acquire), 푸는(release) 동작은 atomic하게 수행된다.(lock을 건 애만 lock을 풀수있다.)
- 예를 들어,
한 손님이 화장실을 사용하려고 하는데 다른 손님이 들어오지 못하게 잠금을 걺(lock). 다른 손님도 이 화장실을 사용하고 싶다면 화장실이 한 개이기 때문에 기존 손님이 나올 때 까지 기다려야함.
- 대기 큐를 생성하여 임계 영역에 스레드가 있을 경우 다른 스레드가 공유 자원을 사용하려고 한다면 스레드를 Blocking하고 대기큐에 Sleep.

### 1.4 Spin Lock vs. Mutex
**공통점**
자원에 대해 사용할 시 락을 걸고 자원이 다른 프로세스/스레드에 의해 점유 중이라면 락이 풀릴 때까지 기다려야 한다는 점

**차이점**
- **스핀락**
무한 루프로 인한 CPU 낭비가 큼 (busy waiting)
lock이 곧 사용가능한 경우라면 Context Switching을 줄여 부하가 줄어듬
하나의 CPU 코어에서는 유용하지 않다.

- ** 뮤텍스**
  Context Switching -> CPU 낭비가 적다
  자원을 얻는 시간이 짧다면 Context Switching으로 인한 낭비가 더 큼
  

### 1.5 Semaphore
- Mutex 보다 더 고차원의 동기화 tool이다.
- 멀티 프로세스 환경에서 프로세스/스레드의 여러개의 공유자원에 대한 접근을 제한하는 방법.
- 예를들어,
  최대 3명의 손님을 식당 식사 자리(공유 자원)에 수용할 수 있다고 가정할 때
  세마포어 S(int)는 식당에 들어갈 수 있는 손님의 수 = 현재 공유 자원에 접근할 수 있는 프로세스/스레드(resource)의 수를 의미
  식당에 들어가는 연산을 P(wait 함수), 식사를 마치고 식당에서 나오는 연산을 V(signal 함수)
  S가 0이라는 것은 모든 손님이 식탁을 점유하여 남은 좌석이 0이라는 뜻!
- P operation은 임계 구역에 들어갈 때 수행하는 동작
if ) S의 값이 3 -> 공유자원이 3개 있으니 P 연산을 통해 S의 값이 2가 된다.
즉, S가 0이 아니라면 S = S - 1 을 한 후 자원을 할당
S가 0이라면 모든 자원이 사용 중이므로 S가 1 이상이 될 때 까지 대기

- V operation은 임계 구역을 나올 때 수행하는 동작
S = S+1 수행하여 자원이 사용가능한 상태임을 나타냄

- 대기하는 방식에는 Busy Waiting과 Block & Wake-up 방식이 있음

#### 1.5.1 busy waiting
```c
P(S) {
     while S <=0; // 무한 루프
     S--;
 }

 V(S) {
     S++;
 }

```
Spin lock 방식
S가 0이하일 때는 계속해서 반복문 수행
-> CPU 시간 낭비, 비효율적인 방법
#### 1.5.2 block & wake-up

```c
 P(S) {
     S--;
     if S < 0
         // 이 프로세스를 대기 큐에 추가
         block(); 
 }

 V(S) {
     S++;
     if S <= 0
         // 대기 큐로부터 제거
         wakeup(); 
 }
```
임계영역에 진입할 때 자원의 값을 감소시킨 후, 만약 자원의 갯수가 음수라서 사용할 수 있는 자원이 없다면 그 프로세스/스레드를 대기큐에 추가.
대기큐에 추가 = block()

자원이 생기면 잠들어있던 프로세스/스레드를 깨운다.
대기큐에서 제거 = wakeup()

### 1.6 Mutex vs. Semaphore
뮤텍스(Mutex)는 이진 세마포어(Binary Semaphore)로 세마포어의 일종 (자원의 갯수 = 1)
뮤텍스는 오직 1개의 프로세스 혹은 스레드만이 공유 자원에 접근할 수 있고, 세마포어는 지정된 변수의 값만큼 접근할 수 있습니다.
